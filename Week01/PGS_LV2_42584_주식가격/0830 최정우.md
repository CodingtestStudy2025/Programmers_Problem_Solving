# PGS_LV2_42584_주식가격[2025.08.30] </br>
문제 : https://school.programmers.co.kr/learn/courses/30/lessons/42584

<접근법 1>
```
이중 for문으로 직접 다 count, O(N^2)
효율성 어케 통과한지 모르겠음
```

```python
def solution(prices):
    # naive
    N = len(prices)

    # 0으로 초기화
    answer = [0 for _ in range(N)]
    
    for i in range(N):
        price_now = prices[i]

        # i부터 끝까지 언제 떨어지나 확인
        for j in range(i+1, N):
            price_next = prices[j]
            answer[i] += 1

            # 떨어지면 for문 빠져나오기
            if price_now > price_next:
                break
            
    return answer
```

<접근법 2>
```
증가할때는 시점을 stack에 push 해뒀다가 
값이 떨어졌을때 현재 값보다 큰 시점들을 pop해서 오른 시간을 update
```

```python
def solution(prices):
    N = len(prices)

    # 하나도 안 떨어졌을 때로 초기화 ([N-1, N-2, ... , 0])
    answer = [N-i-1 for i in range(N)]
    
    # time stack 초기화
    time = [0]
    
    for i in range(1, N):
        price_now = prices[i]
        
        # 안 떨어진 애들 중에 제일 큰 애가 현재보다 작거나 같아질 때 까지 pop 해가면서 update
        # ex) [1,2,3,4], 2 -> [3,4] 시점만 pop해서 update
        while time and prices[time[-1]] > price_now:
            drop = time.pop() # 현재 값보다 큰 시점 (떨어진 애)
            answer[drop] = i - drop # 현재 시점 - 떨어진 애 시점
        
        time.append(i) # 현재 시점은 time에 push
    
    return answer
```
